### 250213 알게된 내용 기록

### 1. React.memo 를 활용한 성능 개선

> - 크롬 브라우저에서 성능 분석하기
>   - 1. 크롬 개발자 도구 
>   - 2. component
>   - 3. component 안에 있는 (톱니바퀴) 클릭
>   - 4. highligt updates when ... 체크 표시
>   - 5. 특정 이벤트 발생 시키기
>   - 6. 이벤트 발생에 따른 렌더링 영역 파악 
> - 프로파일러를 활용하여 실질적인 성능 파악도 가능함 

<br>

### 2. React.memo() 란?
> - 리액트 구동 원리
>   - 리액트는 먼저 컴포넌트를 렌더링한 뒤, 이전에 렌더링된 결과와 비교하여 DOM을 업데이트를 결정함
>   - 렌더링 결과가 이전과 다르다면, React는 DOM을 업데이트함
>   - 해당 과정에서 만약 컴포넌트가 React.memo()로 둘러 쌓여 있다면, 리액트 컴포넌트를 렌더링하고 결과를 메모이징함
>   - 그리고 다음 렌더링이 일어날 때 렌더링하는 컴포넌트의 props가 같다면 리액트는 메모이징된 내용을 제시함
> - 즉, React.memo()는 해당 컴포넌트의 props를 메모이제이션하여 캐시 효과를 기대하여 불피요한 리렌더링을 방지함 

<br>

### 3. 메모이제이션이란?
> - memozation은 주어진 입력값에 대한 결과를 저장함으로써 같은 입력값에 대해 함수가 한번만 실행되는 것을 보장함
> - 즉, 메모리 영역에 이전 값이나 함수 등을 기록하여 그 이후에 특정 작업을 처리할 때 캐시 효과를 보려고 하는 것 

<br>

### 4. React.memo가 props를 비교하는 방법
> - React.memoo()는 props 혹은 props의 객체를 비교할 때 얕은 비교를 함

<br>

### 5. React.memo의 props 비교 방식 커스텀하기
> - 비교 방식을 원하는대로 수정할 수 있음
> - React.memo()의 두 번째 매개변수를 비교함수로 주입하면됨 

<br>

### 6. React.memo 사용을 지양해야 하는 상황
> - 렌더링될 때 props가 다른 경우가 대부분인 상황에서는 React.memo 사용을 지양해야함
>   - 메모이제이션 기법의 이점을 얻기 힘들고 되려 비효율적으로 작업이 처리됨
> - props가 자주 변하는 컴포넌트를 React.memo()로 래핑할지라도 React는 2가지 작업을 리렌더링할 때마다 수행함
>   - (1) 이전 props와 다음 props의 동등 비교를 위해 비교함수를 수행
>   - (2) 비교함수는 거의 false를 반환할 것이기 때문에, 리액트는 이전 렌더링 내용과 다음 렌더링 내용을 비교함 
> - 비교함수의 결과는 대부분 false를 반환하기에 props 비교는 불필요하게 되며 캐시 효과를 못봄(메모이제이션 이점을 못 누림)

<br>

### 7. React.memo는 리렌더링을 막기 위한 도구보다는 성능 개선의 도구
> - 리액트에선 성능 개선을 위한 하나의 도구로 메모이제이션을 활용함
> - 대부분의 상황에서는 리액트 메모이징된 컴포넌트의 리렌더링을 피할 수 있지만, 렌더링을 막기 위해 메모이제이션에 너무 의존하면안됨
> - 따라서, React.memo()를 적용하고 나서 성능이 실질적으로 개선되는지 확인해야함
> - 결론적으로, 리액트에서 성능 최적화를 위해 리액트 컴포넌트를 분리하면 React.memo를 사용함
> - 하지만, React.memo 사용은 항상 좋은 것이기 아니기에 프로파일러를 이용하여 성능상의 이점이 있는지 확인해야함 

<br>

### 8. 얕은 비교 vs 깊은 비교 
> - 얕은 비교는 참조값이 가리키는 객체를 비교하는 것이 아니라 해당 객체가 저장된 위치인 메모리 주소를 비교함
> - 하지만, 깊은 비교는 참조값이 가리키는 객체의 속성들까지도 비교함 

<br>

### 9. 얕은 비교를 사용하는 경우
> - (1) React.memo()에서 props 비교
> - (2) 리액트 컴포넌트가 리렌더링 하기전 
>    - state 변경이 있을 때
>    - 부모 컴포넌트가 렌더링될 대

<br>

### 10. 리액트가 리렌더링되는 경우
> - (1) state 변경이 있을 때
> - (2) 부모 컴포넌트가 렌더링될 때
> - (3) 새로운 props가 들어올 때
> - (4) shouldComponentUpdate에서 true가 반환될 때 
> - (5) forceUpdate가 실행될 때 

<br>

### 11. useCallback을 이용한 함수 최적화
> - 리렌더링 시에 함수 재생성의 문제점 
>   - 원래 컴포넌트가 렌더링될 때, 그 안에 있는 함수도 다시 생성함
>   - 하지만, 똑같은 함수를 컴포넌트가 리렌더링된다고 해서 계속 다시 만드는 것은 좋은 현상이 아님
>   - 그리고 이렇게 컴포넌트가 리렌더링될 때마다 함수를 재생성한다면 이 함수를 전달받는 자식 컴포넌트도 리렌더링이 발생함 
> - useCallback()은 메모이제이션된 함수를 변환하는 함수 
> - useCallback 적용은 useCallback 안에 콜백 함수와 의존성 배열을 순서대로 넣어주면됨 
> - 의존성 배열이 바뀔때만 함수를 재생성함 
> - 함수 내에서 참조하는 state, props가 있다면 의존성 배열에 추가하면됨
> - useCallback으로 인해서 의존성 배열에 추가해준 state 혹은 props가 변하지 않는 다면, 함수는 재생성하지 않음
> - 새로 생성되지 않기 때문에 메모리에 새로 할당하지 않고 동일한 참조값을 사용하게됨
> - 의존성 배열에 아무것도 없다면 컴포넌트가 최초 렌더링 시에만 함수가 생성되며 그 이후에는 동일한 참조값을 사용하는 함수가됨 

<br>

### 12. useMemo()를 이용한 결과값 최적화 
> - 특정 함수에 전달한 매개변수의 값이 이전과 동일하다면, 컴포넌트가 리렌더링 되더라도 연산을 다시 수행하지 않고 이전 렌더링 때 저장한 값을 재활용함 